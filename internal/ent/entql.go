// Code generated by ent, DO NOT EDIT.

package ent

import (
	"lybbrio/internal/ent/author"
	"lybbrio/internal/ent/book"
	"lybbrio/internal/ent/identifier"
	"lybbrio/internal/ent/language"
	"lybbrio/internal/ent/predicate"
	"lybbrio/internal/ent/publisher"
	"lybbrio/internal/ent/series"
	"lybbrio/internal/ent/seriesbook"
	"lybbrio/internal/ent/shelf"
	"lybbrio/internal/ent/tag"
	"lybbrio/internal/ent/user"
	"lybbrio/internal/ent/userpermissions"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 11)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   author.Table,
			Columns: author.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: author.FieldID,
			},
		},
		Type: "Author",
		Fields: map[string]*sqlgraph.FieldSpec{
			author.FieldName: {Type: field.TypeString, Column: author.FieldName},
			author.FieldSort: {Type: field.TypeString, Column: author.FieldSort},
			author.FieldLink: {Type: field.TypeString, Column: author.FieldLink},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   book.Table,
			Columns: book.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: book.FieldID,
			},
		},
		Type: "Book",
		Fields: map[string]*sqlgraph.FieldSpec{
			book.FieldTitle:       {Type: field.TypeString, Column: book.FieldTitle},
			book.FieldSort:        {Type: field.TypeString, Column: book.FieldSort},
			book.FieldAddedAt:     {Type: field.TypeTime, Column: book.FieldAddedAt},
			book.FieldPubDate:     {Type: field.TypeTime, Column: book.FieldPubDate},
			book.FieldPath:        {Type: field.TypeString, Column: book.FieldPath},
			book.FieldIsbn:        {Type: field.TypeString, Column: book.FieldIsbn},
			book.FieldDescription: {Type: field.TypeString, Column: book.FieldDescription},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   identifier.Table,
			Columns: identifier.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: identifier.FieldID,
			},
		},
		Type: "Identifier",
		Fields: map[string]*sqlgraph.FieldSpec{
			identifier.FieldType:  {Type: field.TypeEnum, Column: identifier.FieldType},
			identifier.FieldValue: {Type: field.TypeString, Column: identifier.FieldValue},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   language.Table,
			Columns: language.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: language.FieldID,
			},
		},
		Type: "Language",
		Fields: map[string]*sqlgraph.FieldSpec{
			language.FieldName: {Type: field.TypeString, Column: language.FieldName},
			language.FieldCode: {Type: field.TypeString, Column: language.FieldCode},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   publisher.Table,
			Columns: publisher.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: publisher.FieldID,
			},
		},
		Type: "Publisher",
		Fields: map[string]*sqlgraph.FieldSpec{
			publisher.FieldName: {Type: field.TypeString, Column: publisher.FieldName},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   series.Table,
			Columns: series.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: series.FieldID,
			},
		},
		Type: "Series",
		Fields: map[string]*sqlgraph.FieldSpec{
			series.FieldName: {Type: field.TypeString, Column: series.FieldName},
			series.FieldSort: {Type: field.TypeString, Column: series.FieldSort},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   seriesbook.Table,
			Columns: seriesbook.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: seriesbook.FieldID,
			},
		},
		Type: "SeriesBook",
		Fields: map[string]*sqlgraph.FieldSpec{
			seriesbook.FieldSeriesIndex: {Type: field.TypeFloat64, Column: seriesbook.FieldSeriesIndex},
			seriesbook.FieldSeriesID:    {Type: field.TypeString, Column: seriesbook.FieldSeriesID},
			seriesbook.FieldBookID:      {Type: field.TypeString, Column: seriesbook.FieldBookID},
		},
	}
	graph.Nodes[7] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   shelf.Table,
			Columns: shelf.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: shelf.FieldID,
			},
		},
		Type: "Shelf",
		Fields: map[string]*sqlgraph.FieldSpec{
			shelf.FieldPublic:      {Type: field.TypeBool, Column: shelf.FieldPublic},
			shelf.FieldUserID:      {Type: field.TypeString, Column: shelf.FieldUserID},
			shelf.FieldName:        {Type: field.TypeString, Column: shelf.FieldName},
			shelf.FieldDescription: {Type: field.TypeString, Column: shelf.FieldDescription},
		},
	}
	graph.Nodes[8] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   tag.Table,
			Columns: tag.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: tag.FieldID,
			},
		},
		Type: "Tag",
		Fields: map[string]*sqlgraph.FieldSpec{
			tag.FieldName: {Type: field.TypeString, Column: tag.FieldName},
		},
	}
	graph.Nodes[9] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldUsername:     {Type: field.TypeString, Column: user.FieldUsername},
			user.FieldPasswordHash: {Type: field.TypeString, Column: user.FieldPasswordHash},
			user.FieldEmail:        {Type: field.TypeString, Column: user.FieldEmail},
		},
	}
	graph.Nodes[10] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   userpermissions.Table,
			Columns: userpermissions.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: userpermissions.FieldID,
			},
		},
		Type: "UserPermissions",
		Fields: map[string]*sqlgraph.FieldSpec{
			userpermissions.FieldUserID:                 {Type: field.TypeString, Column: userpermissions.FieldUserID},
			userpermissions.FieldAdmin:                  {Type: field.TypeBool, Column: userpermissions.FieldAdmin},
			userpermissions.FieldCanCreatePublicShelves: {Type: field.TypeBool, Column: userpermissions.FieldCanCreatePublicShelves},
		},
	}
	graph.MustAddE(
		"books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   author.BooksTable,
			Columns: author.BooksPrimaryKey,
			Bidi:    false,
		},
		"Author",
		"Book",
	)
	graph.MustAddE(
		"authors",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   book.AuthorsTable,
			Columns: book.AuthorsPrimaryKey,
			Bidi:    false,
		},
		"Book",
		"Author",
	)
	graph.MustAddE(
		"series",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   book.SeriesTable,
			Columns: book.SeriesPrimaryKey,
			Bidi:    false,
		},
		"Book",
		"Series",
	)
	graph.MustAddE(
		"identifier",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   book.IdentifierTable,
			Columns: []string{book.IdentifierColumn},
			Bidi:    false,
		},
		"Book",
		"Identifier",
	)
	graph.MustAddE(
		"language",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   book.LanguageTable,
			Columns: []string{book.LanguageColumn},
			Bidi:    false,
		},
		"Book",
		"Language",
	)
	graph.MustAddE(
		"shelf",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   book.ShelfTable,
			Columns: book.ShelfPrimaryKey,
			Bidi:    false,
		},
		"Book",
		"Shelf",
	)
	graph.MustAddE(
		"book",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   identifier.BookTable,
			Columns: []string{identifier.BookColumn},
			Bidi:    false,
		},
		"Identifier",
		"Book",
	)
	graph.MustAddE(
		"books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   language.BooksTable,
			Columns: []string{language.BooksColumn},
			Bidi:    false,
		},
		"Language",
		"Book",
	)
	graph.MustAddE(
		"books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   publisher.BooksTable,
			Columns: []string{publisher.BooksColumn},
			Bidi:    false,
		},
		"Publisher",
		"Book",
	)
	graph.MustAddE(
		"books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   series.BooksTable,
			Columns: series.BooksPrimaryKey,
			Bidi:    false,
		},
		"Series",
		"Book",
	)
	graph.MustAddE(
		"series_books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   series.SeriesBooksTable,
			Columns: []string{series.SeriesBooksColumn},
			Bidi:    false,
		},
		"Series",
		"SeriesBook",
	)
	graph.MustAddE(
		"series",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   seriesbook.SeriesTable,
			Columns: []string{seriesbook.SeriesColumn},
			Bidi:    false,
		},
		"SeriesBook",
		"Series",
	)
	graph.MustAddE(
		"book",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   seriesbook.BookTable,
			Columns: []string{seriesbook.BookColumn},
			Bidi:    false,
		},
		"SeriesBook",
		"Book",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   shelf.UserTable,
			Columns: []string{shelf.UserColumn},
			Bidi:    false,
		},
		"Shelf",
		"User",
	)
	graph.MustAddE(
		"books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   shelf.BooksTable,
			Columns: shelf.BooksPrimaryKey,
			Bidi:    false,
		},
		"Shelf",
		"Book",
	)
	graph.MustAddE(
		"books",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tag.BooksTable,
			Columns: []string{tag.BooksColumn},
			Bidi:    false,
		},
		"Tag",
		"Book",
	)
	graph.MustAddE(
		"shelves",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ShelvesTable,
			Columns: []string{user.ShelvesColumn},
			Bidi:    false,
		},
		"User",
		"Shelf",
	)
	graph.MustAddE(
		"userPermissions",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.UserPermissionsTable,
			Columns: []string{user.UserPermissionsColumn},
			Bidi:    false,
		},
		"User",
		"UserPermissions",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   userpermissions.UserTable,
			Columns: []string{userpermissions.UserColumn},
			Bidi:    false,
		},
		"UserPermissions",
		"User",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (aq *AuthorQuery) addPredicate(pred func(s *sql.Selector)) {
	aq.predicates = append(aq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the AuthorQuery builder.
func (aq *AuthorQuery) Filter() *AuthorFilter {
	return &AuthorFilter{config: aq.config, predicateAdder: aq}
}

// addPredicate implements the predicateAdder interface.
func (m *AuthorMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the AuthorMutation builder.
func (m *AuthorMutation) Filter() *AuthorFilter {
	return &AuthorFilter{config: m.config, predicateAdder: m}
}

// AuthorFilter provides a generic filtering capability at runtime for AuthorQuery.
type AuthorFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *AuthorFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *AuthorFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(author.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *AuthorFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(author.FieldName))
}

// WhereSort applies the entql string predicate on the sort field.
func (f *AuthorFilter) WhereSort(p entql.StringP) {
	f.Where(p.Field(author.FieldSort))
}

// WhereLink applies the entql string predicate on the link field.
func (f *AuthorFilter) WhereLink(p entql.StringP) {
	f.Where(p.Field(author.FieldLink))
}

// WhereHasBooks applies a predicate to check if query has an edge books.
func (f *AuthorFilter) WhereHasBooks() {
	f.Where(entql.HasEdge("books"))
}

// WhereHasBooksWith applies a predicate to check if query has an edge books with a given conditions (other predicates).
func (f *AuthorFilter) WhereHasBooksWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (bq *BookQuery) addPredicate(pred func(s *sql.Selector)) {
	bq.predicates = append(bq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the BookQuery builder.
func (bq *BookQuery) Filter() *BookFilter {
	return &BookFilter{config: bq.config, predicateAdder: bq}
}

// addPredicate implements the predicateAdder interface.
func (m *BookMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the BookMutation builder.
func (m *BookMutation) Filter() *BookFilter {
	return &BookFilter{config: m.config, predicateAdder: m}
}

// BookFilter provides a generic filtering capability at runtime for BookQuery.
type BookFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *BookFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *BookFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(book.FieldID))
}

// WhereTitle applies the entql string predicate on the title field.
func (f *BookFilter) WhereTitle(p entql.StringP) {
	f.Where(p.Field(book.FieldTitle))
}

// WhereSort applies the entql string predicate on the sort field.
func (f *BookFilter) WhereSort(p entql.StringP) {
	f.Where(p.Field(book.FieldSort))
}

// WhereAddedAt applies the entql time.Time predicate on the added_at field.
func (f *BookFilter) WhereAddedAt(p entql.TimeP) {
	f.Where(p.Field(book.FieldAddedAt))
}

// WherePubDate applies the entql time.Time predicate on the pub_date field.
func (f *BookFilter) WherePubDate(p entql.TimeP) {
	f.Where(p.Field(book.FieldPubDate))
}

// WherePath applies the entql string predicate on the path field.
func (f *BookFilter) WherePath(p entql.StringP) {
	f.Where(p.Field(book.FieldPath))
}

// WhereIsbn applies the entql string predicate on the isbn field.
func (f *BookFilter) WhereIsbn(p entql.StringP) {
	f.Where(p.Field(book.FieldIsbn))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *BookFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(book.FieldDescription))
}

// WhereHasAuthors applies a predicate to check if query has an edge authors.
func (f *BookFilter) WhereHasAuthors() {
	f.Where(entql.HasEdge("authors"))
}

// WhereHasAuthorsWith applies a predicate to check if query has an edge authors with a given conditions (other predicates).
func (f *BookFilter) WhereHasAuthorsWith(preds ...predicate.Author) {
	f.Where(entql.HasEdgeWith("authors", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasSeries applies a predicate to check if query has an edge series.
func (f *BookFilter) WhereHasSeries() {
	f.Where(entql.HasEdge("series"))
}

// WhereHasSeriesWith applies a predicate to check if query has an edge series with a given conditions (other predicates).
func (f *BookFilter) WhereHasSeriesWith(preds ...predicate.Series) {
	f.Where(entql.HasEdgeWith("series", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasIdentifier applies a predicate to check if query has an edge identifier.
func (f *BookFilter) WhereHasIdentifier() {
	f.Where(entql.HasEdge("identifier"))
}

// WhereHasIdentifierWith applies a predicate to check if query has an edge identifier with a given conditions (other predicates).
func (f *BookFilter) WhereHasIdentifierWith(preds ...predicate.Identifier) {
	f.Where(entql.HasEdgeWith("identifier", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasLanguage applies a predicate to check if query has an edge language.
func (f *BookFilter) WhereHasLanguage() {
	f.Where(entql.HasEdge("language"))
}

// WhereHasLanguageWith applies a predicate to check if query has an edge language with a given conditions (other predicates).
func (f *BookFilter) WhereHasLanguageWith(preds ...predicate.Language) {
	f.Where(entql.HasEdgeWith("language", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasShelf applies a predicate to check if query has an edge shelf.
func (f *BookFilter) WhereHasShelf() {
	f.Where(entql.HasEdge("shelf"))
}

// WhereHasShelfWith applies a predicate to check if query has an edge shelf with a given conditions (other predicates).
func (f *BookFilter) WhereHasShelfWith(preds ...predicate.Shelf) {
	f.Where(entql.HasEdgeWith("shelf", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (iq *IdentifierQuery) addPredicate(pred func(s *sql.Selector)) {
	iq.predicates = append(iq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the IdentifierQuery builder.
func (iq *IdentifierQuery) Filter() *IdentifierFilter {
	return &IdentifierFilter{config: iq.config, predicateAdder: iq}
}

// addPredicate implements the predicateAdder interface.
func (m *IdentifierMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the IdentifierMutation builder.
func (m *IdentifierMutation) Filter() *IdentifierFilter {
	return &IdentifierFilter{config: m.config, predicateAdder: m}
}

// IdentifierFilter provides a generic filtering capability at runtime for IdentifierQuery.
type IdentifierFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *IdentifierFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *IdentifierFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(identifier.FieldID))
}

// WhereType applies the entql string predicate on the type field.
func (f *IdentifierFilter) WhereType(p entql.StringP) {
	f.Where(p.Field(identifier.FieldType))
}

// WhereValue applies the entql string predicate on the value field.
func (f *IdentifierFilter) WhereValue(p entql.StringP) {
	f.Where(p.Field(identifier.FieldValue))
}

// WhereHasBook applies a predicate to check if query has an edge book.
func (f *IdentifierFilter) WhereHasBook() {
	f.Where(entql.HasEdge("book"))
}

// WhereHasBookWith applies a predicate to check if query has an edge book with a given conditions (other predicates).
func (f *IdentifierFilter) WhereHasBookWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("book", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (lq *LanguageQuery) addPredicate(pred func(s *sql.Selector)) {
	lq.predicates = append(lq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the LanguageQuery builder.
func (lq *LanguageQuery) Filter() *LanguageFilter {
	return &LanguageFilter{config: lq.config, predicateAdder: lq}
}

// addPredicate implements the predicateAdder interface.
func (m *LanguageMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the LanguageMutation builder.
func (m *LanguageMutation) Filter() *LanguageFilter {
	return &LanguageFilter{config: m.config, predicateAdder: m}
}

// LanguageFilter provides a generic filtering capability at runtime for LanguageQuery.
type LanguageFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *LanguageFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *LanguageFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(language.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *LanguageFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(language.FieldName))
}

// WhereCode applies the entql string predicate on the code field.
func (f *LanguageFilter) WhereCode(p entql.StringP) {
	f.Where(p.Field(language.FieldCode))
}

// WhereHasBooks applies a predicate to check if query has an edge books.
func (f *LanguageFilter) WhereHasBooks() {
	f.Where(entql.HasEdge("books"))
}

// WhereHasBooksWith applies a predicate to check if query has an edge books with a given conditions (other predicates).
func (f *LanguageFilter) WhereHasBooksWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (pq *PublisherQuery) addPredicate(pred func(s *sql.Selector)) {
	pq.predicates = append(pq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the PublisherQuery builder.
func (pq *PublisherQuery) Filter() *PublisherFilter {
	return &PublisherFilter{config: pq.config, predicateAdder: pq}
}

// addPredicate implements the predicateAdder interface.
func (m *PublisherMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the PublisherMutation builder.
func (m *PublisherMutation) Filter() *PublisherFilter {
	return &PublisherFilter{config: m.config, predicateAdder: m}
}

// PublisherFilter provides a generic filtering capability at runtime for PublisherQuery.
type PublisherFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *PublisherFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *PublisherFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(publisher.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *PublisherFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(publisher.FieldName))
}

// WhereHasBooks applies a predicate to check if query has an edge books.
func (f *PublisherFilter) WhereHasBooks() {
	f.Where(entql.HasEdge("books"))
}

// WhereHasBooksWith applies a predicate to check if query has an edge books with a given conditions (other predicates).
func (f *PublisherFilter) WhereHasBooksWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (sq *SeriesQuery) addPredicate(pred func(s *sql.Selector)) {
	sq.predicates = append(sq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the SeriesQuery builder.
func (sq *SeriesQuery) Filter() *SeriesFilter {
	return &SeriesFilter{config: sq.config, predicateAdder: sq}
}

// addPredicate implements the predicateAdder interface.
func (m *SeriesMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the SeriesMutation builder.
func (m *SeriesMutation) Filter() *SeriesFilter {
	return &SeriesFilter{config: m.config, predicateAdder: m}
}

// SeriesFilter provides a generic filtering capability at runtime for SeriesQuery.
type SeriesFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *SeriesFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *SeriesFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(series.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *SeriesFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(series.FieldName))
}

// WhereSort applies the entql string predicate on the sort field.
func (f *SeriesFilter) WhereSort(p entql.StringP) {
	f.Where(p.Field(series.FieldSort))
}

// WhereHasBooks applies a predicate to check if query has an edge books.
func (f *SeriesFilter) WhereHasBooks() {
	f.Where(entql.HasEdge("books"))
}

// WhereHasBooksWith applies a predicate to check if query has an edge books with a given conditions (other predicates).
func (f *SeriesFilter) WhereHasBooksWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasSeriesBooks applies a predicate to check if query has an edge series_books.
func (f *SeriesFilter) WhereHasSeriesBooks() {
	f.Where(entql.HasEdge("series_books"))
}

// WhereHasSeriesBooksWith applies a predicate to check if query has an edge series_books with a given conditions (other predicates).
func (f *SeriesFilter) WhereHasSeriesBooksWith(preds ...predicate.SeriesBook) {
	f.Where(entql.HasEdgeWith("series_books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (sbq *SeriesBookQuery) addPredicate(pred func(s *sql.Selector)) {
	sbq.predicates = append(sbq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the SeriesBookQuery builder.
func (sbq *SeriesBookQuery) Filter() *SeriesBookFilter {
	return &SeriesBookFilter{config: sbq.config, predicateAdder: sbq}
}

// addPredicate implements the predicateAdder interface.
func (m *SeriesBookMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the SeriesBookMutation builder.
func (m *SeriesBookMutation) Filter() *SeriesBookFilter {
	return &SeriesBookFilter{config: m.config, predicateAdder: m}
}

// SeriesBookFilter provides a generic filtering capability at runtime for SeriesBookQuery.
type SeriesBookFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *SeriesBookFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *SeriesBookFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(seriesbook.FieldID))
}

// WhereSeriesIndex applies the entql float64 predicate on the series_index field.
func (f *SeriesBookFilter) WhereSeriesIndex(p entql.Float64P) {
	f.Where(p.Field(seriesbook.FieldSeriesIndex))
}

// WhereSeriesID applies the entql string predicate on the series_id field.
func (f *SeriesBookFilter) WhereSeriesID(p entql.StringP) {
	f.Where(p.Field(seriesbook.FieldSeriesID))
}

// WhereBookID applies the entql string predicate on the book_id field.
func (f *SeriesBookFilter) WhereBookID(p entql.StringP) {
	f.Where(p.Field(seriesbook.FieldBookID))
}

// WhereHasSeries applies a predicate to check if query has an edge series.
func (f *SeriesBookFilter) WhereHasSeries() {
	f.Where(entql.HasEdge("series"))
}

// WhereHasSeriesWith applies a predicate to check if query has an edge series with a given conditions (other predicates).
func (f *SeriesBookFilter) WhereHasSeriesWith(preds ...predicate.Series) {
	f.Where(entql.HasEdgeWith("series", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasBook applies a predicate to check if query has an edge book.
func (f *SeriesBookFilter) WhereHasBook() {
	f.Where(entql.HasEdge("book"))
}

// WhereHasBookWith applies a predicate to check if query has an edge book with a given conditions (other predicates).
func (f *SeriesBookFilter) WhereHasBookWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("book", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (sq *ShelfQuery) addPredicate(pred func(s *sql.Selector)) {
	sq.predicates = append(sq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ShelfQuery builder.
func (sq *ShelfQuery) Filter() *ShelfFilter {
	return &ShelfFilter{config: sq.config, predicateAdder: sq}
}

// addPredicate implements the predicateAdder interface.
func (m *ShelfMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ShelfMutation builder.
func (m *ShelfMutation) Filter() *ShelfFilter {
	return &ShelfFilter{config: m.config, predicateAdder: m}
}

// ShelfFilter provides a generic filtering capability at runtime for ShelfQuery.
type ShelfFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ShelfFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[7].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *ShelfFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(shelf.FieldID))
}

// WherePublic applies the entql bool predicate on the public field.
func (f *ShelfFilter) WherePublic(p entql.BoolP) {
	f.Where(p.Field(shelf.FieldPublic))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *ShelfFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(shelf.FieldUserID))
}

// WhereName applies the entql string predicate on the name field.
func (f *ShelfFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(shelf.FieldName))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *ShelfFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(shelf.FieldDescription))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *ShelfFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *ShelfFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasBooks applies a predicate to check if query has an edge books.
func (f *ShelfFilter) WhereHasBooks() {
	f.Where(entql.HasEdge("books"))
}

// WhereHasBooksWith applies a predicate to check if query has an edge books with a given conditions (other predicates).
func (f *ShelfFilter) WhereHasBooksWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (tq *TagQuery) addPredicate(pred func(s *sql.Selector)) {
	tq.predicates = append(tq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TagQuery builder.
func (tq *TagQuery) Filter() *TagFilter {
	return &TagFilter{config: tq.config, predicateAdder: tq}
}

// addPredicate implements the predicateAdder interface.
func (m *TagMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TagMutation builder.
func (m *TagMutation) Filter() *TagFilter {
	return &TagFilter{config: m.config, predicateAdder: m}
}

// TagFilter provides a generic filtering capability at runtime for TagQuery.
type TagFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TagFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[8].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *TagFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(tag.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *TagFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(tag.FieldName))
}

// WhereHasBooks applies a predicate to check if query has an edge books.
func (f *TagFilter) WhereHasBooks() {
	f.Where(entql.HasEdge("books"))
}

// WhereHasBooksWith applies a predicate to check if query has an edge books with a given conditions (other predicates).
func (f *TagFilter) WhereHasBooksWith(preds ...predicate.Book) {
	f.Where(entql.HasEdgeWith("books", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: uq.config, predicateAdder: uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[9].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *UserFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(user.FieldID))
}

// WhereUsername applies the entql string predicate on the username field.
func (f *UserFilter) WhereUsername(p entql.StringP) {
	f.Where(p.Field(user.FieldUsername))
}

// WherePasswordHash applies the entql string predicate on the passwordHash field.
func (f *UserFilter) WherePasswordHash(p entql.StringP) {
	f.Where(p.Field(user.FieldPasswordHash))
}

// WhereEmail applies the entql string predicate on the email field.
func (f *UserFilter) WhereEmail(p entql.StringP) {
	f.Where(p.Field(user.FieldEmail))
}

// WhereHasShelves applies a predicate to check if query has an edge shelves.
func (f *UserFilter) WhereHasShelves() {
	f.Where(entql.HasEdge("shelves"))
}

// WhereHasShelvesWith applies a predicate to check if query has an edge shelves with a given conditions (other predicates).
func (f *UserFilter) WhereHasShelvesWith(preds ...predicate.Shelf) {
	f.Where(entql.HasEdgeWith("shelves", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUserPermissions applies a predicate to check if query has an edge userPermissions.
func (f *UserFilter) WhereHasUserPermissions() {
	f.Where(entql.HasEdge("userPermissions"))
}

// WhereHasUserPermissionsWith applies a predicate to check if query has an edge userPermissions with a given conditions (other predicates).
func (f *UserFilter) WhereHasUserPermissionsWith(preds ...predicate.UserPermissions) {
	f.Where(entql.HasEdgeWith("userPermissions", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (upq *UserPermissionsQuery) addPredicate(pred func(s *sql.Selector)) {
	upq.predicates = append(upq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserPermissionsQuery builder.
func (upq *UserPermissionsQuery) Filter() *UserPermissionsFilter {
	return &UserPermissionsFilter{config: upq.config, predicateAdder: upq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserPermissionsMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserPermissionsMutation builder.
func (m *UserPermissionsMutation) Filter() *UserPermissionsFilter {
	return &UserPermissionsFilter{config: m.config, predicateAdder: m}
}

// UserPermissionsFilter provides a generic filtering capability at runtime for UserPermissionsQuery.
type UserPermissionsFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserPermissionsFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[10].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *UserPermissionsFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(userpermissions.FieldID))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *UserPermissionsFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(userpermissions.FieldUserID))
}

// WhereAdmin applies the entql bool predicate on the admin field.
func (f *UserPermissionsFilter) WhereAdmin(p entql.BoolP) {
	f.Where(p.Field(userpermissions.FieldAdmin))
}

// WhereCanCreatePublicShelves applies the entql bool predicate on the CanCreatePublicShelves field.
func (f *UserPermissionsFilter) WhereCanCreatePublicShelves(p entql.BoolP) {
	f.Where(p.Field(userpermissions.FieldCanCreatePublicShelves))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *UserPermissionsFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *UserPermissionsFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
